<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VinuChain Staking Hub</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Inter', sans-serif;
            background: #000000;
            color: #FFFFFF;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            width: 90%;
            padding: 30px;
            animation: fadeIn 1.2s ease;
        }
        header {
            text-align: center;
            margin-bottom: 40px;
        }
        header img {
            width: 160px;
            filter: drop-shadow(0 2px 4px rgba(76, 175, 80, 0.3));
            animation: bounceIn 1s ease;
        }
        h1 {
            font-size: 2.8em;
            font-weight: 700;
            margin: 15px 0;
            background: linear-gradient(90deg, #FFFFFF, #4CAF50);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: fadeInDown 1.2s ease;
        }
        button {
            background: linear-gradient(45deg, #4CAF50, #66BB6A);
            color: #FFFFFF;
            border: none;
            padding: 14px 28px;
            margin: 8px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: transform 0.3s, box-shadow 0.3s, background 0.3s;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }
        button:hover {
            background: linear-gradient(45deg, #388E3C, #4CAF50);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.5);
        }
        button:disabled {
            background: #555555;
            cursor: not-allowed;
            box-shadow: none;
        }
        .section {
            background: #1A1A1A;
            border: 1px solid transparent;
            border-image: linear-gradient(45deg, #4CAF50, #1A1A1A) 1;
            border-radius: 12px;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 0 4px 20px rgba(76, 175, 80, 0.15);
            animation: slideInUp 0.6s ease;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .section:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 25px rgba(76, 175, 80, 0.25);
        }
        .section h2 {
            font-size: 2em;
            font-weight: 600;
            margin-bottom: 20px;
            color: #4CAF50;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        input, textarea {
            width: 100%;
            padding: 14px;
            margin: 8px 0;
            border-radius: 8px;
            border: 1px solid #333333;
            background: #222222;
            color: #FFFFFF;
            font-size: 14px;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        input:focus, textarea:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.3);
        }
        input::placeholder, textarea::placeholder {
            color: #999999;
            font-style: italic;
        }
        textarea {
            resize: vertical;
            min-height: 120px;
        }
        ul {
            list-style: none;
            padding: 0;
        }
        li {
            background: #222222;
            padding: 20px;
            margin: 8px 0;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s, transform 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
        li:hover {
            background: #2A2A2A;
            transform: translateY(-2px);
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.4s ease;
        }
        .modal.show {
            display: flex;
        }
        .modal-content {
            background: #1A1A1A;
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
            position: relative;
            animation: zoomIn 0.4s ease;
        }
        .close-modal {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 1.8em;
            cursor: pointer;
            color: #CCCCCC;
            transition: color 0.3s;
        }
        .close-modal:hover {
            color: #4CAF50;
        }
        #loading {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 30px;
            border-radius: 8px;
            color: #4CAF50;
            font-weight: 500;
            animation: pulse 1.2s infinite;
        }
        #error {
            color: #FF4D4D;
            margin: 15px 0;
            text-align: center;
            font-weight: 500;
        }
        #progress {
            color: #4CAF50;
            margin: 15px 0;
            text-align: center;
            font-weight: 500;
        }
        .copy-btn, .fund-btn {
            background: linear-gradient(45deg, #4CAF50, #66BB6A);
            padding: 8px 12px;
            font-size: 13px;
            margin-left: 12px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(76, 175, 80, 0.3);
        }
        .copy-btn:hover, .fund-btn:hover {
            background: linear-gradient(45deg, #388E3C, #4CAF50);
            box-shadow: 0 3px 8px rgba(76, 175, 80, 0.5);
        }
        .status-indicator {
            font-size: 13px;
            color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            margin-left: 12px;
        }
        .guide-section {
            background: #1A1A1A;
            border: 1px solid transparent;
            border-image: linear-gradient(45deg, #4CAF50, #1A1A1A) 1;
            border-radius: 12px;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 0 4px 20px rgba(76, 175, 80, 0.15);
        }
        .guide-section a {
            color: #4CAF50;
            text-decoration: none;
            transition: color 0.3s;
        }
        .guide-section a:hover {
            color: #66BB6A;
        }
        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        .stat-card {
            background: #222222;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            animation: slideInLeft 0.6s ease;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .stat-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }
        .stat-card h3 {
            font-size: 1.3em;
            font-weight: 600;
            color: #4CAF50;
            margin-bottom: 10px;
        }
        .history-section {
            background: #1A1A1A;
            border: 1px solid transparent;
            border-image: linear-gradient(45deg, #4CAF50, #1A1A1A) 1;
            border-radius: 12px;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 0 4px 20px rgba(76, 175, 80, 0.15);
        }
        .history-section ul {
            max-height: 240px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #4CAF50 #222222;
        }
        .history-section ul::-webkit-scrollbar {
            width: 8px;
        }
        .history-section ul::-webkit-scrollbar-track {
            background: #222222;
        }
        .history-section ul::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 4px;
        }
        #stakingChart {
            background: #1A1A1A;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(76, 175, 80, 0.15);
            margin: 20px 0;
        }
        @media (max-width: 768px) {
            h1 { font-size: 2em; }
            .section { padding: 20px; }
            button { padding: 12px 20px; font-size: 14px; }
            .stats-section { grid-template-columns: 1fr; }
            .container { padding: 20px; }
            header img { width: 120px; }
            .modal-content { padding: 20px; }
        }
        @media (max-width: 480px) {
            button { padding: 10px 16px; }
            .stat-card { padding: 15px; }
            .section h2 { font-size: 1.6em; }
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(1); }
        }
        @keyframes zoomIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        @keyframes slideInUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes slideInLeft {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.4/dist/web3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <img src="https://photos.pinksale.finance/file/pinksale-logo-upload/1759847695513-f915ce15471ce09f03d8fbf68bc0616f.png" alt="VinuChain Staking Hub Logo">
            <h1>VinuChain Staking Hub</h1>
            <p id="account">Not Connected</p>
            <button id="connectWallet">Connect Wallet</button>
        </header>
        <div id="error"></div>
        <div id="progress"></div>
        <section id="analytics">
            <h2>Advanced Staking Analytics</h2>
            <div class="stats-section">
                <div class="stat-card">
                    <h3>Total TVL Across Pools</h3>
                    <p id="totalTVL">0</p>
                </div>
                <div class="stat-card">
                    <h3>Average APR</h3>
                    <p id="averageAPR">0%</p>
                </div>
                <div class="stat-card">
                    <h3>Total Stakers</h3>
                    <p id="totalStakers">0</p>
                </div>
                <div class="stat-card">
                    <h3>Your Total Staked</h3>
                    <p id="userTotalStaked">0</p>
                </div>
                <div class="stat-card">
                    <h3>Your Pending Rewards</h3>
                    <p id="userPendingRewards">0</p>
                </div>
            </div>
            <canvas id="stakingChart" width="400" height="200"></canvas>
        </section>
        <div class="section">
            <h2>Create Pool</h2>
            <input type="text" id="tokenAddress" placeholder="Token Address" aria-label="Token Address">
            <p id="tokenInfo"></p>
            <button id="createPool">Create Pool</button>
        </div>
        <div class="section">
            <h2>Interact with Pool</h2>
            <input type="text" id="poolAddress" placeholder="Pool Address" aria-label="Pool Address">
            <button id="stake">Stake</button>
            <button id="unstake">Unstake</button>
            <button id="claim">Claim Rewards</button>
            <button id="togglePause">Toggle Pause</button>
        </div>
        <div class="section">
            <h2>Reward Calculator</h2>
            <input type="number" id="calcAmount" placeholder="Stake Amount" aria-label="Stake Amount">
            <input type="number" id="calcAPR" placeholder="APR (%)" aria-label="APR">
            <input type="number" id="calcDays" placeholder="Days" aria-label="Days">
            <button id="calculate">Calculate</button>
            <p id="calcResult">Estimated Rewards: 0</p>
        </div>
        <div class="section">
            <h2>Explore & Stake Pools</h2>
            <input type="text" id="poolSearch" placeholder="Search Pools" aria-label="Search Pools">
            <ul id="allPools"></ul>
        </div>
        <div class="section">
            <h2>Your Pools</h2>
            <ul id="userPools"></ul>
        </div>
        <div class="section">
            <h2>Staked Pools</h2>
            <p id="totalEarnings">Total Earnings: 0</p>
            <ul id="stakedPools"></ul>
        </div>
        <div class="history-section">
            <h2>Transaction History</h2>
            <ul id="txHistory"></ul>
        </div>
        <div class="guide-section">
            <h2>Verify Your Pool Contract</h2>
            <p>Copy the Solidity code below and use it to verify your pool contract on <a href="https://explorer.vinuchain.org" target="_blank">VinuChain Explorer</a>.</p>
            <textarea id="contractCode" readonly>
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}

contract StakingPool is Context {
    address public stakeToken;
    address public creator;
    uint256 public apr;
    uint256 public lockDays;
    uint256 public minStake;
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public lastStakedTime;
    uint256 public totalStaked;
    uint256 public totalStakers;
    bool public paused;

    constructor(address _stakeToken, uint256 _apr, uint256 _lockDays, uint256 _minStake, address _creator) {
        stakeToken = _stakeToken;
        apr = _apr;
        lockDays = _lockDays;
        minStake = _minStake;
        creator = _creator;
    }

    function stake(uint256 amount) external {
        require(!paused, "Pool is paused");
        require(amount >= minStake, "Below minimum stake");
        IERC20(stakeToken).transferFrom(_msgSender(), address(this), amount);
        stakedBalance[_msgSender()] += amount;
        lastStakedTime[_msgSender()] = block.timestamp;
        totalStaked += amount;
        if (stakedBalance[_msgSender()] == amount) totalStakers += 1;
    }

    function unstake() external {
        require(!paused, "Pool is paused");
        require(stakedBalance[_msgSender()] > 0, "No stake");
        require(block.timestamp >= lastStakedTime[_msgSender()] + lockDays * 1 days, "Lock period not over");
        uint256 amount = stakedBalance[_msgSender()];
        stakedBalance[_msgSender()] = 0;
        totalStaked -= amount;
        totalStakers -= 1;
        IERC20(stakeToken).transfer(_msgSender(), amount);
    }

    function getPendingRewards(address user) external view returns (uint256) {
        uint256 timeElapsed = block.timestamp - lastStakedTime[user];
        return (stakedBalance[user] * apr * timeElapsed) / (365 * 1 days * 100);
    }

    function claimRewards() external {
        require(!paused, "Pool is paused");
        uint256 rewards = this.getPendingRewards(_msgSender());
        require(rewards > 0, "No rewards");
        lastStakedTime[_msgSender()] = block.timestamp;
        IERC20(stakeToken).transfer(_msgSender(), rewards);
    }

    function pause(bool _status) external {
        require(_msgSender() == creator, "Not creator");
        paused = _status;
    }
}
            </textarea>
            <button class="copy-btn" onclick="copyToClipboard(document.getElementById('contractCode').value)">Copy Contract Code</button>
            <p>Steps to verify:</p>
            <ol>
                <li>Visit <a href="https://explorer.vinuchain.org" target="_blank">VinuChain Explorer</a> and search for your pool address.</li>
                <li>Click "Verify & Publish Contract Source Code."</li>
                <li>Select "Single File," paste the code above, and enter constructor arguments:
                    <ul>
                        <li><code>stakeToken</code>: Token address used in pool creation.</li>
                        <li><code>apr</code>: APR in basis points (e.g., 10% = 1000).</li>
                        <li><code>lockDays</code>: Lock period in days (e.g., 30).</li>
                        <li><code>minStake</code>: Minimum stake in Wei (e.g., 100 * 10^18).</li>
                        <li><code>creator</code>: Your wallet address.</li>
                    </ul>
                </li>
                <li>Submit and wait for verification (1-5 minutes).</li>
            </ol>
        </div>
        <div id="loading">Loading...</div>
        <div id="modal" class="modal">
            <div class="modal-content">
                <span class="close-modal">&times;</span>
                <h2 id="modalTitle"></h2>
                <div id="modalBody"></div>
                <button id="modalAction"></button>
            </div>
        </div>
    </div>

    <script>
        const web3 = new Web3(window.ethereum || 'https://rpc.vinuchain.org');
        const factoryAddress = '0xEb82A52577AF54C2Fc40c3695f144aEa3FD7a4E3';
        const factoryABI = [
            {
                "inputs": [{"internalType": "address", "name": "_feeWallet", "type": "address"}],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "internalType": "address", "name": "poolAddress", "type": "address"},
                    {"indexed": false, "internalType": "address", "name": "creator", "type": "address"},
                    {"indexed": false, "internalType": "address", "name": "token", "type": "address"},
                    {"indexed": false, "internalType": "uint256", "name": "apr", "type": "uint256"},
                    {"indexed": false, "internalType": "uint256", "name": "lockDays", "type": "uint256"},
                    {"indexed": false, "internalType": "uint256", "name": "minStake", "type": "uint256"},
                    {"indexed": false, "internalType": "string", "name": "name", "type": "string"},
                    {"indexed": false, "internalType": "string", "name": "description", "type": "string"}
                ],
                "name": "PoolCreated",
                "type": "event"
            },
            {
                "inputs": [],
                "name": "CREATE_FEE",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "address", "name": "stakeToken", "type": "address"},
                    {"internalType": "uint256", "name": "apr", "type": "uint256"},
                    {"internalType": "uint256", "name": "lockDays", "type": "uint256"},
                    {"internalType": "uint256", "name": "minStake", "type": "uint256"},
                    {"internalType": "string", "name": "name", "type": "string"},
                    {"internalType": "string", "name": "description", "type": "string"}
                ],
                "name": "createPool",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "feeWallet",
                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getAllPools",
                "outputs": [{"internalType": "address[]", "name": "", "type": "address[]"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "poolAddress", "type": "address"}],
                "name": "getPoolInfo",
                "outputs": [
                    {
                        "components": [
                            {"internalType": "address", "name": "poolAddress", "type": "address"},
                            {"internalType": "address", "name": "stakeToken", "type": "address"},
                            {"internalType": "uint256", "name": "apr", "type": "uint256"},
                            {"internalType": "uint256", "name": "lockDays", "type": "uint256"},
                            {"internalType": "uint256", "name": "minStake", "type": "uint256"},
                            {"internalType": "string", "name": "name", "type": "string"},
                            {"internalType": "string", "name": "description", "type": "string"}
                        ],
                        "internalType": "struct StakingFactory.PoolInfo",
                        "name": "",
                        "type": "tuple"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "user", "type": "address"}],
                "name": "getUserPools",
                "outputs": [{"internalType": "address[]", "name": "", "type": "address[]"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "", "type": "address"}],
                "name": "poolInfo",
                "outputs": [
                    {"internalType": "address", "name": "poolAddress", "type": "address"},
                    {"internalType": "address", "name": "stakeToken", "type": "address"},
                    {"internalType": "uint256", "name": "apr", "type": "uint256"},
                    {"internalType": "uint256", "name": "lockDays", "type": "uint256"},
                    {"internalType": "uint256", "name": "minStake", "type": "uint256"},
                    {"internalType": "string", "name": "name", "type": "string"},
                    {"internalType": "string", "name": "description", "type": "string"}
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "name": "pools",
                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "address", "name": "", "type": "address"},
                    {"internalType": "uint256", "name": "", "type": "uint256"}
                ],
                "name": "userPools",
                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];
        const poolABI = [
            {"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"stake","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[],"name":"unstake","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[],"name":"claimRewards","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getPendingRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"apr","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"lockDays","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"minStake","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"totalStaked","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"totalStakers","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"stakeToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"stakedBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"bool","name":"_status","type":"bool"}],"name":"pause","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}
        ];
        const erc20ABI = [
            {"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"}
        ];

        let account;
        const factory = new web3.eth.Contract(factoryABI, factoryAddress);
        const modal = document.getElementById('modal');
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');
        const modalAction = document.getElementById('modalAction');
        const loading = document.getElementById('loading');
        const errorEl = document.getElementById('error');
        const progress = document.getElementById('progress');
        const connectWalletButton = document.getElementById('connectWallet');
        let txHistory = [];
        let chartInstance = null; // <-- FIX: Track chart to destroy it

        function showLoading(show) {
            loading.style.display = show ? 'block' : 'none';
        }

        function showError(msg) {
            errorEl.textContent = msg || '';
            console.error('Error:', msg);
        }

        function showProgress(msg) {
            progress.textContent = msg || '';
        }

        function showModal(title, body, actionText, action) {
            modalTitle.textContent = title;
            modalBody.innerHTML = body;
            modalAction.textContent = actionText;
            modalAction.onclick = action;
            modal.classList.add('show');
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showModal('Success', 'Copied to clipboard!', 'Close', () => modal.classList.remove('show'));
            }).catch(err => {
                showError('Failed to copy: ' + err.message);
                console.error('Copy error:', err);
            });
        }

        function addToTxHistory(type, txHash, poolAddr) {
            txHistory.push({ type, txHash, poolAddr, timestamp: new Date().toLocaleString() });
            if (txHistory.length > 10) txHistory.shift();
            updateTxHistory();
        }

        function updateTxHistory() {
            const historyList = document.getElementById('txHistory');
            historyList.innerHTML = '';
            txHistory.forEach(tx => {
                const li = document.createElement('li');
                li.innerHTML = `<span>${tx.type} | Tx: ${tx.txHash.slice(0, 6)}... | Pool: ${tx.poolAddr.slice(0, 6)}... | ${tx.timestamp}</span>`;
                historyList.appendChild(li);
            });
        }

        document.querySelector('.close-modal')?.addEventListener('click', () => {
            modal.classList.remove('show');
        });

        async function addVinuChainNetwork() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0xcf' }],
                });
            } catch (switchError) {
                if (switchError.code === 4902) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: '0xcf',
                                chainName: 'VinuChain',
                                rpcUrls: ['https://rpc.vinuchain.org'],
                                nativeCurrency: { name: 'VinuChain', symbol: 'VC', decimals: 18 },
                                blockExplorerUrls: ['https://explorer.vinuchain.org']
                            }],
                        });
                    } catch (addError) {
                        showError('Failed to add VinuChain network: ' + addError.message);
                    }
                } else {
                    showError('Failed to switch to VinuChain: ' + switchError.message);
                }
            }
        }

        async function disconnectWallet() {
            account = null;
            document.getElementById('account').textContent = 'Not Connected';
            connectWalletButton.textContent = 'Connect Wallet';
            connectWalletButton.onclick = connectWallet;
            document.getElementById('userPools').innerHTML = '';
            document.getElementById('stakedPools').innerHTML = '';
            document.getElementById('totalEarnings').textContent = 'Total Earnings: 0';
            document.getElementById('totalTVL').textContent = '0';
            document.getElementById('averageAPR').textContent = '0%';
            document.getElementById('totalStakers').textContent = '0';
            document.getElementById('userTotalStaked').textContent = '0';
            document.getElementById('userPendingRewards').textContent = '0';
            if (window.ethereum) {
                try {
                    await window.ethereum.request({
                        method: 'wallet_revokePermissions',
                        params: [{ eth_accounts: {} }],
                    });
                } catch (err) {
                    console.warn('MetaMask disconnect not supported:', err);
                }
            }
        }

        async function connectWallet() {
            if (!window.ethereum) {
                showError('MetaMask not detected! Please install MetaMask and refresh.');
                return;
            }
            try {
                showLoading(true);
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                if (chainId !== '0xcf') {
                    await addVinuChainNetwork();
                }
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (accounts.length === 0) {
                    showError('No accounts found. Please unlock MetaMask.');
                    return;
                }
                account = accounts[0];
                document.getElementById('account').textContent = `Connected: ${account.slice(0, 6)}...${account.slice(-4)}`;
                connectWalletButton.textContent = 'Disconnect Wallet';
                connectWalletButton.onclick = disconnectWallet;
                await loadPools();
                await loadUserDashboard();
            } catch (err) {
                showError('Connection failed: ' + err.message);
            } finally {
                showLoading(false);
            }
        }

        connectWalletButton?.addEventListener('click', () => {
            connectWallet();
        });

        document.getElementById('tokenAddress')?.addEventListener('input', async (e) => {
            const addr = e.target.value.trim();
            if (web3.utils.isAddress(addr)) {
                const token = new web3.eth.Contract(erc20ABI, addr);
                try {
                    const symbol = await token.methods.symbol().call();
                    const decimals = await token.methods.decimals().call();
                    document.getElementById('tokenInfo').textContent = `Token: ${symbol} (Decimals: ${decimals})`;
                } catch {
                    document.getElementById('tokenInfo').textContent = 'Invalid token address';
                }
            } else {
                document.getElementById('tokenInfo').textContent = '';
            }
        });

        document.getElementById('createPool')?.addEventListener('click', () => {
            if (!account) {
                showError('Please connect your wallet first.');
                return;
            }
            showModal('Create Pool', `
                <form id="createPoolForm">
                    <p>Token Address:</p>
                    <input id="modalTokenAddress" type="text" placeholder="ERC20 Token Address" required>
                    <p>APR (%):</p>
                    <input id="modalApr" type="number" min="0.01" step="0.01" placeholder="e.g., 10" required>
                    <p>Lock Days (integer):</p>
                    <input id="modalLockDays" type="number" min="1" step="1" placeholder="e.g., 30" required>
                    <p>Minimum Stake (Tokens):</p>
                    <input id="modalMinStake" type="number" min="0.01" step="0.01" placeholder="e.g., 100" required>
                    <p>Pool Name (max 50 chars):</p>
                    <input id="modalName" type="text" placeholder="e.g., Vinu Rewards" maxlength="50" required>
                    <p>Description (max 200 chars):</p>
                    <textarea id="modalDescription" placeholder="e.g., High APR staking!" maxlength="200"></textarea>
                </form>
            `, 'Create', async () => {
                const form = document.getElementById('createPoolForm');
                if (!form.checkValidity()) {
                    showError('Please fill all required fields correctly.');
                    form.reportValidity();
                    return;
                }
                const token = document.getElementById('modalTokenAddress').value.trim();
                const apr = parseFloat(document.getElementById('modalApr').value);
                const lockDays = parseInt(document.getElementById('modalLockDays').value, 10);
                const minStake = parseFloat(document.getElementById('modalMinStake').value);
                const name = document.getElementById('modalName').value.trim();
                const description = document.getElementById('modalDescription').value.trim();

                if (!web3.utils.isAddress(token)) { showError('Invalid token address'); return; }
                if (isNaN(apr) || apr <= 0) { showError('APR must be positive'); return; }
                if (isNaN(lockDays) || lockDays <= 0 || !Number.isInteger(lockDays)) { showError('Lock days must be positive integer'); return; }
                if (isNaN(minStake) || minStake <= 0) { showError('Min stake must be positive'); return; }
                if (!name || name.length > 50) { showError('Name required (≤50 chars)'); return; }
                if (description.length > 200) { showError('Description ≤200 chars'); return; }

                try {
                    showLoading(true);
                    const tokenContract = new web3.eth.Contract(erc20ABI, token);
                    const decimals = await tokenContract.methods.decimals().call();
                    const minStakeWei = web3.utils.toWei(minStake.toString(), 'ether');
                    const aprBasisPoints = Math.floor(apr * 100);
                    const createFee = await factory.methods.CREATE_FEE().call();
                    const balance = await web3.eth.getBalance(account);
                    if (web3.utils.toBN(balance).lt(web3.utils.toBN(createFee))) {
                        showError(`Insufficient VC for ${web3.utils.fromWei(createFee, 'ether')} VC fee`);
                        return;
                    }
                    const createPoolTx = factory.methods.createPool(
                        token, aprBasisPoints, lockDays, minStakeWei, name, description || ''
                    );
                    const gas = await createPoolTx.estimateGas({ from: account, value: createFee });
                    const tx = await createPoolTx.send({
                        from: account,
                        value: createFee,
                        gas: Math.floor(gas * 1.5),
                        gasPrice: await web3.eth.getGasPrice()
                    });
                    const poolAddr = tx.events.PoolCreated.returnValues.poolAddress;
                    addToTxHistory('Pool Created', tx.transactionHash, poolAddr);
                    showModal('Pool Created', `
                        Pool created! Tx: ${tx.transactionHash.slice(0,6)}...<br>
                        Pool Address: ${poolAddr} <button class="copy-btn" onclick="copyToClipboard('${poolAddr}')">Copy</button>
                    `, 'Close', () => modal.classList.remove('show'));
                    await loadPools();
                    await loadUserDashboard();
                } catch (err) {
                    showError('Pool creation failed: ' + err.message);
                } finally {
                    showLoading(false);
                    showProgress('');
                }
            });
        });

        async function fundPool(poolAddr) {
            if (!account) { showError('Connect wallet first'); return; }
            const pool = new web3.eth.Contract(poolABI, poolAddr);
            let tokenAddr, symbol;
            try {
                tokenAddr = await pool.methods.stakeToken().call();
                const token = new web3.eth.Contract(erc20ABI, tokenAddr);
                symbol = await token.methods.symbol().call();
            } catch { showError('Invalid pool'); return; }

            showModal('Fund Pool', `
                <form id="fundPoolForm">
                    <p>Amount to fund (${symbol}):</p>
                    <input id="modalFundAmount" type="number" min="0.01" step="0.01" placeholder="Amount" required>
                </form>
            `, 'Fund', async () => {
                const amount = parseFloat(document.getElementById('modalFundAmount').value);
                if (isNaN(amount) || amount <= 0) { showError('Invalid amount'); return; }
                try {
                    showLoading(true);
                    const amountWei = web3.utils.toWei(amount.toString(), 'ether');
                    const token = new web3.eth.Contract(erc20ABI, tokenAddr);
                    await token.methods.approve(poolAddr, amountWei).send({ from: account });
                    const tx = await token.methods.transfer(poolAddr, amountWei).send({ from: account });
                    addToTxHistory('Pool Funded', tx.transactionHash, poolAddr);
                    modal.classList.remove('show');
                    showModal('Success', `Funded ${amount} ${symbol}!`, 'Close', () => modal.classList.remove('show'));
                    await loadUserDashboard();
                } catch (err) {
                    showError('Funding failed: ' + err.message);
                } finally {
                    showLoading(false);
                }
            });
        }

        document.getElementById('stake')?.addEventListener('click', async () => {
            if (!account) { showError('Connect wallet'); return; }
            const poolAddr = document.getElementById('poolAddress').value.trim();
            const pool = new web3.eth.Contract(poolABI, poolAddr);
            let minStake, tokenAddr, token, decimals;
            try {
                minStake = await pool.methods.minStake().call();
                tokenAddr = await pool.methods.stakeToken().call();
                token = new web3.eth.Contract(erc20ABI, tokenAddr);
                decimals = await token.methods.decimals().call();
                const minStakeFormatted = web3.utils.fromWei(minStake, 'ether');
                showModal('Stake Tokens', `
                    <form id="stakeForm">
                        <p>Amount (Min: ${minStakeFormatted}):</p>
                        <input id="modalStakeAmount" type="number" min="${minStakeFormatted}" step="0.01" placeholder="Amount" required>
                    </form>
                `, 'Approve & Stake', async () => {
                    const amount = parseFloat(document.getElementById('modalStakeAmount').value);
                    if (amount < parseFloat(minStakeFormatted)) { showError('Below min stake'); return; }
                    try {
                        showLoading(true);
                        const amountWei = web3.utils.toWei(amount.toString(), 'ether');
                        await token.methods.approve(poolAddr, amountWei).send({ from: account });
                        const tx = await pool.methods.stake(amountWei).send({ from: account });
                        addToTxHistory('Stake', tx.transactionHash, poolAddr);
                        modal.classList.remove('show');
                        await loadUserDashboard();
                    } catch (err) {
                        showError(err.message);
                    } finally {
                        showLoading(false);
                    }
                });
            } catch { showError('Invalid pool'); }
        });

        document.getElementById('unstake')?.addEventListener('click', async () => {
            if (!account) { showError('Connect wallet'); return; }
            const poolAddr = document.getElementById('poolAddress').value.trim();
            try {
                showLoading(true);
                const pool = new web3.eth.Contract(poolABI, poolAddr);
                const tx = await pool.methods.unstake().send({ from: account });
                addToTxHistory('Unstake', tx.transactionHash, poolAddr);
                showModal('Success', 'Unstaked!', 'Close', () => modal.classList.remove('show'));
                await loadUserDashboard();
            } catch (err) {
                showError(err.message);
            } finally {
                showLoading(false);
            }
        });

        document.getElementById('claim')?.addEventListener('click', async () => {
            if (!account) { showError('Connect wallet'); return; }
            const poolAddr = document.getElementById('poolAddress').value.trim();
            try {
                showLoading(true);
                const pool = new web3.eth.Contract(poolABI, poolAddr);
                const tx = await pool.methods.claimRewards().send({ from: account });
                addToTxHistory('Claim Rewards', tx.transactionHash, poolAddr);
                showModal('Success', 'Rewards claimed!', 'Close', () => modal.classList.remove('show'));
                await loadUserDashboard();
            } catch (err) {
                showError(err.message);
            } finally {
                showLoading(false);
            }
        });

        document.getElementById('togglePause')?.addEventListener('click', async () => {
            if (!account) { showError('Connect wallet'); return; }
            const poolAddr = document.getElementById('poolAddress').value.trim();
            try {
                showLoading(true);
                const pool = new web3.eth.Contract(poolABI, poolAddr);
                const isPaused = await pool.methods.paused().call();
                const tx = await pool.methods.pause(!isPaused).send({ from: account });
                addToTxHistory(isPaused ? 'Unpaused' : 'Paused', tx.transactionHash, poolAddr);
                showModal('Success', `Pool ${isPaused ? 'unpaused' : 'paused'}!`, 'Close', () => modal.classList.remove('show'));
                await loadUserDashboard();
            } catch (err) {
                showError(err.message);
            } finally {
                showLoading(false);
            }
        });

        document.getElementById('poolSearch')?.addEventListener('input', (e) => {
            const search = e.target.value.toLowerCase();
            document.querySelectorAll('#allPools li').forEach(li => {
                li.style.display = li.textContent.toLowerCase().includes(search) ? 'block' : 'none';
            });
        });

        document.getElementById('calculate')?.addEventListener('click', () => {
            const amount = parseFloat(document.getElementById('calcAmount').value) || 0;
            const apr = parseFloat(document.getElementById('calcAPR').value) || 0;
            const days = parseFloat(document.getElementById('calcDays').value) || 0;
            const rewards = (amount * apr * days) / (365 * 100);
            document.getElementById('calcResult').textContent = `Estimated Rewards: ${rewards.toFixed(2)}`;
        });

        async function loadAnalytics() {
            try {
                const allPools = await factory.methods.getAllPools().call();
                let totalTVL = 0, totalAPR = 0, totalStakers = 0, userTotalStaked = 0, userPendingRewards = 0;
                let stakingData = [];

                for (let poolAddr of allPools) {
                    const pool = new web3.eth.Contract(poolABI, poolAddr);
                    const poolInfo = await factory.methods.getPoolInfo(poolAddr).call();
                    const totalStakedPool = web3.utils.fromWei(await pool.methods.totalStaked().call());
                    const totalStakersPool = await pool.methods.totalStakers().call();
                    totalTVL += parseFloat(totalStakedPool);
                    totalAPR += parseFloat(poolInfo.apr / 100);
                    totalStakers += parseInt(totalStakersPool);
                    stakingData.push(parseFloat(totalStakedPool));

                    if (account) {
                        const staked = web3.utils.fromWei(await pool.methods.stakedBalance(account).call());
                        const rewards = web3.utils.fromWei(await pool.methods.getPendingRewards(account).call());
                        userTotalStaked += parseFloat(staked);
                        userPendingRewards += parseFloat(rewards);
                    }
                }

                document.getElementById('totalTVL').textContent = totalTVL.toFixed(2);
                document.getElementById('averageAPR').textContent = (totalAPR / allPools.length || 0).toFixed(2) + '%';
                document.getElementById('totalStakers').textContent = totalStakers;
                if (account) {
                    document.getElementById('userTotalStaked').textContent = userTotalStaked.toFixed(2);
                    document.getElementById('userPendingRewards').textContent = userPendingRewards.toFixed(2);
                }

                const ctx = document.getElementById('stakingChart').getContext('2d');

                // FIX: Destroy previous chart before creating new one
                if (chartInstance) {
                    chartInstance.destroy();
                }

                chartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: allPools.map((_, i) => `Pool ${i + 1}`),
                        datasets: [{
                            label: 'Staked Amount',
                            data: stakingData,
                            backgroundColor: ctx => {
                                const gradient = ctx.chart.ctx.createLinearGradient(0, 0, 0, 200);
                                gradient.addColorStop(0, 'rgba(76, 175, 80, 0.8)');
                                gradient.addColorStop(1, 'rgba(76, 175, 80, 0.4)');
                                return gradient;
                            },
                            borderColor: '#4CAF50',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        scales: {
                            y: { beginAtZero: true, ticks: { color: '#CCCCCC' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } },
                            x: { ticks: { color: '#CCCCCC' }, grid: { display: false } }
                        },
                        plugins: {
                            legend: { labels: { color: '#FFFFFF', font: { size: 14 } } },
                            tooltip: { backgroundColor: '#1A1A1A', titleColor: '#FFFFFF', bodyColor: '#FFFFFF', borderColor: '#4CAF50', borderWidth: 1 }
                        }
                    }
                });
            } catch (err) {
                showError('Failed to load analytics: ' + err.message);
                console.error(err);
            }
        }

        async function loadPools() {
            showLoading(true);
            try {
                const allPools = await factory.methods.getAllPools().call();
                const allList = document.getElementById('allPools');
                allList.innerHTML = '';
                for (let poolAddr of allPools) {
                    const pool = new web3.eth.Contract(poolABI, poolAddr);
                    const poolInfo = await factory.methods.getPoolInfo(poolAddr).call();
                    const tokenAddr = await pool.methods.stakeToken().call();
                    const token = new web3.eth.Contract(erc20ABI, tokenAddr);
                    const symbol = await token.methods.symbol().call().catch(() => 'UNKNOWN');
                    const minStakeFormatted = web3.utils.fromWei(poolInfo.minStake, 'ether');
                    const totalStakedFormatted = web3.utils.fromWei(await pool.methods.totalStaked().call(), 'ether');
                    const isPaused = await pool.methods.paused().call();
                    const li = document.createElement('li');
                    li.innerHTML = `<span>${poolInfo.name} (${symbol}) | APR: ${poolInfo.apr / 100}% | Lock: ${poolInfo.lockDays}d | Min: ${minStakeFormatted}</span><span>TVL: ${totalStakedFormatted} ${symbol} | Stakers: ${await pool.methods.totalStakers().call()} | ${poolInfo.description} <span class="status-indicator">${isPaused ? 'Paused' : 'Active'}</span></span>`;
                    li.onclick = () => document.getElementById('poolAddress').value = poolAddr;
                    allList.appendChild(li);
                }
                await loadAnalytics();
            } catch (err) {
                showError('Failed to load pools: ' + err.message);
            } finally {
                showLoading(false);
            }
        }

        async function loadUserDashboard() {
            if (!account) return;
            showLoading(true);
            try {
                const userPools = await factory.methods.getUserPools(account).call();
                const userList = document.getElementById('userPools');
                userList.innerHTML = '';
                for (let poolAddr of userPools) {
                    const pool = new web3.eth.Contract(poolABI, poolAddr);
                    const poolInfo = await factory.methods.getPoolInfo(poolAddr).call();
                    const tokenAddr = await pool.methods.stakeToken().call();
                    const token = new web3.eth.Contract(erc20ABI, tokenAddr);
                    const symbol = await token.methods.symbol().call().catch(() => 'UNKNOWN');
                    const isPaused = await pool.methods.paused().call();
                    const li = document.createElement('li');
                    li.innerHTML = `<span>${poolInfo.name} (${symbol}) | APR: ${poolInfo.apr / 100}% | Address: ${poolAddr.slice(0,6)}... <span class="status-indicator">${isPaused ? 'Paused' : 'Active'}</span></span><span><button class="copy-btn" onclick="copyToClipboard('${poolAddr}')">Copy Address</button><button class="fund-btn" onclick="fundPool('${poolAddr}')">Fund Pool</button></span>`;
                    userList.appendChild(li);
                }
                const allPools = await factory.methods.getAllPools().call();
                const stakedList = document.getElementById('stakedPools');
                stakedList.innerHTML = '';
                let totalRewards = 0;
                for (let poolAddr of allPools) {
                    const pool = new web3.eth.Contract(poolABI, poolAddr);
                    const staked = await pool.methods.stakedBalance(account).call();
                    if (staked > 0) {
                        const rewards = web3.utils.fromWei(await pool.methods.getPendingRewards(account).call(), 'ether');
                        totalRewards += parseFloat(rewards);
                        const poolInfo = await factory.methods.getPoolInfo(poolAddr).call();
                        const tokenAddr = await pool.methods.stakeToken().call();
                        const token = new web3.eth.Contract(erc20ABI, tokenAddr);
                        const symbol = await token.methods.symbol().call().catch(() => 'UNKNOWN');
                        const isPaused = await pool.methods.paused().call();
                        const li = document.createElement('li');
                        li.innerHTML = `<span>${poolInfo.name} (${symbol}) | Staked: ${web3.utils.fromWei(staked, 'ether')} <span class="status-indicator">${isPaused ? 'Paused' : 'Active'}</span></span><span>Rewards: ${rewards}</span>`;
                        li.onclick = () => document.getElementById('poolAddress').value = poolAddr;
                        stakedList.appendChild(li);
                    }
                }
                document.getElementById('totalEarnings').textContent = `Total Earnings: ${totalRewards.toFixed(2)}`;
                await loadAnalytics();
            } catch (err) {
                showError('Failed to load dashboard: ' + err.message);
            } finally {
                showLoading(false);
            }
        }

        if (window.ethereum && window.ethereum.selectedAddress) {
            account = window.ethereum.selectedAddress;
            document.getElementById('account').textContent = `Connected: ${account.slice(0, 6)}...${account.slice(-4)}`;
            connectWalletButton.textContent = 'Disconnect Wallet';
            connectWalletButton.onclick = disconnectWallet;
            loadPools();
            loadUserDashboard();
        }
    </script>
</body>
</html>
